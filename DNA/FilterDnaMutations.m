function [samplesToUse, mutationsToUse] =FilterDnaMutations(dnaData,varargin)

% Convenience function to filter dna mutations and samples	
% INPUT
% dnaData   -     struct containing combined DNA data as generated by Generate_DNA_Results
%
% Various filtering options are below in parsing function arguments.
%              
% OUTPUT
%   dnaSamplesToUse   - a numeric array containing indices of samples satisfying conditions
%   dnaMutationsToUse   - a numeric array containing indices of dna mutations satisfying conditions
p=inputParser;


% Lowest value of the variant-allele-frequency to be considered a mutation
defaultMinVAF=0;
addOptional(p,'minVAF',defaultMinVAF,@(x) validateattributes(x,{'numeric'},...
    {'scalar','>=',0,'<=',1}));

% Determines whether mutations at the same site, and whose status is
% identical across all samples should be replaced by a single mutation
addOptional(p,'groupMutations',true,@(x) islogical(x));

addOptional(p,'filterMouse',false,@(x) islogical(x));

defaultMutationTypeToDrop={'none'};
validMutationTypes={'.','frameshift_deletion','frameshift_insertion',...
    'frameshift_substitution','nonframeshift_deletion',...
    'nonframeshift_insertion','nonframeshift_substitution',...
    'nonsynonymous_SNV', 'stopgain','stoploss','synonymous_SNV','none'};
addOptional(p,'mutationTypesToDrop',defaultMutationTypeToDrop,@(x) iscell(x) && ...
    all(ismember(x,validMutationTypes)));

addOptional(p,'keepOnlyCOSMIC',false,@(x) islogical(x));

addOptional(p,'dropNOCALL',true,@(x) islogical(x));


parse(p,varargin{:});

%%
params=GetParams({'DNA','samples'});

numberOfSamples=params.samples.numberOfSamples;
numberOfMutations=length(dnaData.eventInfo);
samplesToUse=1:numberOfSamples;
samplesToUse(params.dna.badSamples)=[];

mutTypeFilter=~ismember({dnaData.eventInfo.mutType},p.Results.mutationTypesToDrop);

if(p.Results.keepOnlyCOSMIC)
    cosmicFilter=~strcmp({dnaData.eventInfo.cosmic},'.');
else
    cosmicFilter=true(numberOfMutations,1);
end

if(p.Results.dropNOCALL)
    qualityFilter=~strcmp({dnaData.eventInfo.filter},'NOCALL');
else
    qualityFilter=true(numberOfMutations,1);
end

if(p.Results.filterMouse)
    mutatedInMouse=dnaData.isMutated(37,:)|dnaData.altAlleleFraction(37,:)>0;
    pos=regexp(dnaData.uniqueIDs,'_','split');
    pos=cellfun(@(x) strcat(x{1},'_',x{2}),pos,'Unif',false);
    mouseFilter=~ismember(pos,pos(mutatedInMouse))';
else
    mouseFilter=true(1,numberOfMutations);
end

isMutated=(any(dnaData.isMutated(samplesToUse,:)&...
    dnaData.altAlleleFraction(samplesToUse,:)>=p.Results.minVAF)&...
    mouseFilter)';

filteredGenes=find(isMutated(:)&cosmicFilter(:)&qualityFilter(:)&mutTypeFilter(:));



%%

if(p.Results.groupMutations)
    isMut=dnaData.isMutated(samplesToUse,:);isMut=isMut(:,filteredGenes);
    vaf=dnaData.altAlleleFraction(samplesToUse,:);vaf=vaf(:,filteredGenes);
    genePos=strcat({dnaData.eventInfo(filteredGenes).geneName},...
        '_',{dnaData.eventInfo(filteredGenes).pos});
    
    [a,~,geneGroupNum]=unique(genePos);
    
    groupRepresentativeIdxs=[];
    
    for i=1:length(a)
        sameEvent=find(geneGroupNum==i);
        if(numel(sameEvent)>1)
            eVaf=mean(vaf(:,sameEvent),1);
            % find connected components
            adjMat=squareform(pdist(double(isMut(:,sameEvent)')))==0;
            g=graph(adjMat);
            connComp=conncomp(g,'OutputForm','cell');
            for component=1:length(connComp)
                % find highest vaf
                [~,idx]=max(eVaf(connComp{component}));
                 % represent group by that element
                repElement=sameEvent(connComp{component}(idx));
                groupRepresentativeIdxs=[groupRepresentativeIdxs;repElement];
                
            end
          
        else
            groupRepresentativeIdxs=[groupRepresentativeIdxs;sameEvent];
            
        end
    end
    mutationsToUse=filteredGenes(groupRepresentativeIdxs);
    
else
    mutationsToUse=filteredGenes;
end
end
